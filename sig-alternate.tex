% This is "sig-alternate.tex" V2.0 May 2012
% This file should be compiled with V2.5 of "sig-alternate.cls" May 2012
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.5 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.5) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V2.0 - May 2012

\documentclass{sig-alternate}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{bbding}
\usepackage{pifont}

\begin{document}
%
% --- Author Metadata here ---
\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{Comparative Analysis of Multi Paradigms Languages}

%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{8} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
Faisal Mumtaz\\
       \affaddr{i16-1024}\\
       \affaddr{MS(CS)}
% 2nd. author
\alignauthor
Faisal Mumtaz\\
\affaddr{i16-1024}\\
\affaddr{MS(CS)}
% 3rd. author
\alignauthor Umar Munir\\
\affaddr{i16-1011}\\
\affaddr{MS(CS)}
\and  % use '\and' if you need 'another row' of author names
% 4th. author
% 4th. author
\alignauthor Shahran Gohar \\
\affaddr{i16-1024}\\
\affaddr{MS(CS)}
% 5th. author
\alignauthor Mehreen Alam\\
\affaddr{i16-1024}\\
\affaddr{MS(CS)}
% 6th. author
\alignauthor Shahid Hussain\\
\affaddr{i16-1024}\\
\affaddr{MS(CS)}
}

\maketitle
\begin{abstract}

\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging}

\section{Introduction}



\section{Related Work}

\section{Features}

\subsection{Bound Checking}
In computer programming, bound checking is any method of whether variable detecting variable is within bound before it is used.  A failed bounds check usually results in the generation of some sort of exception signal.
\subsubsection{Range checking}
It is usually used to check that whether a number fits into a given type. A range check is a check to make sure a number is within a certain range; for example, range check will ensure that a value that will assign to a 16-bit integer is within the capacity of a 16-bit integer. Some range checks may be more restrictive; for example, a variable to hold the number of a calendar month may be declared to accept only the range 1 to 12

\subsubsection{Index checking}
In index checking a variable being used as an array index is within the bounds of the array. Index checking means all expressions indexing an array, the index value is checked against the bounds of the array, which were created when the array was defined, and if the index is out-of-bounds, an error occur and further execution is suspended. If a number outside of the upper range is used in an array, it may cause the program to crash, or may introduce security vulnerabilities, index checking is a part of many high-level languages.
\begin{table}[]
	\centering
	\caption{Index Checking}
	\label{my-label}
	\begin{tabular}{|l|c|l|}
		\hline
		& Index checking                                              & Range checking                                                   \\ \hline
		Scala  &               \ding{52}                                              & \begin{tabular}[c]{@{}l@{}}\ding{52}\\   (statically check)\end{tabular} \\ \hline
		Swift  & \ding{52}                                                           & \ding{52}                                                                \\ \hline
		F\#    & \ding{52}                                                           & \ding{52}                                                                \\ \hline
		Rust   & \begin{tabular}[c]{@{}c@{}}\ding{52}\\   (at run time)\end{tabular} & -                                                                \\ \hline
		Vb.net & \ding{52}                                                           & \ding{52}                                                                \\ \hline
		C\#    & \ding{52}                                                           & \ding{52}                                                                \\ \hline
		D      & \ding{54}                                                           & \ding{52}                                                                \\ \hline
		Oz     & -                                                           & -                                                                \\ \hline
		Matlab & \ding{52}                                                           & \begin{tabular}[c]{@{}l@{}}\ding{52}(statically\\   check)\end{tabular}  \\ \hline
		Python & \ding{52}                                                           & \ding{52}                                                                \\ \hline
	\end{tabular}
\end{table}

\subsubsection{Examples}
\subsubsection{Scala}
Array representation in scala \\
scala> val a1 = Array(1, 2, 3) \\
a1: Array[Int] = Array(1, 2, 3)
\subsubsection{Swift-range checking }
func contains(Bound)
Returns a Boolean value indicating whether the given element is contained within the range.


\subsection{Type Safety}
The compiler will validate types and through an error if you assign a wrong type to a variable. 
Type safety is checking for matched data types during compile time. For example, int a ="John" returns error as variable 'a' is an integer and we are assigning a string value. These data type mismatches are checked during compile time. Type safe code can access only the memory locations that it has permission to execute. Type safe code can never access any private members of an object. Type safe code ensures that objects are isolated from each other and are therefore safe for inadvertent or malicious corruption
\subsubsection{The advantages type safety }
At compile time, we get an error when a type instance is being assigned to an incompatible type; hence preventing an error at runtime. So at compilation time itself, developers come to know such errors and code will be modified to correct the mistake. So developers get more confidence in their code.
Run time type safety ensures, we don't get strange memory exceptions and inconsistent behavior in the application.

\subsubsection{scala}
Scala is strongly type and smart about static type. Scala has powerful type inference. It will figure out itself mostly no need to tell it the types of your variables. 
\subsubsection{Swift}
Swift is type safe, it performs type checks when compiling code and flags any mismatched types as errors. This help in early catch and fix error in the development process. 
It provides type inference which basically means that coders don’t require to spend more time in defining what types of variables they are using.
\subsubsection{F\#}
In f\#, static type checking can use almost as an instant unit test – making sure that your code is correct at compile time.
F\# is more type-safe than C\#, and how the F\# compiler can catch errors that would only be detected at runtime in C\#.
\subsubsection{Rust }
Rust is a type-safe language. Rust has an escape valve from the safety rules. When you absolutely have to use a raw pointer. This is called unsafe code, and while most Rust programs dont need it, 
how to use it and how it fits into Rust\'s overall safety scheme in
 \\ https://www.safaribooksonline.com/library/view/programming-rust/9781491927274/ch21.html\#unsafe-code

\subsubsection{VB.net}
Type safety in .NET has been introduced to prevent the objects of one type from peeking into the memory assigned for the other object.
\subsubsection{C\#}
Type safety prevents assigning a type to another type when are not compatible.
public class Employee{}

public class Student{}
In the above example, Employee and Student are two incompatible types. We cannot assign an object of employee class to Student class variable. If you try doing so, you will get an error during the compilation process. Type safety check happens at compile time it's called static type checking
Example
Cannot implicitly convert type 'Program.Employee' to 'Program.Student'.
. When tried to type cast object of wrong type. We get 
Unable to cast object of type ‘first object’ to ‘second object’
type checking happens at runtime, hence it is called runtime type checking
\subsubsection{D}
D has compile-time type safety. 
\subsubsection{OZ }
OZ also known as MOZART. Oz variables are single-assignment variables or more appropriately logic variables. A single assignment variable has a number of phases in its lifetime. Initially it is introduced with unknown value, and later it might be assigned a value, in which case the variable becomes bound. Once a variable is bound, it cannot itself be changed.
\subsubsection{Matlab}
MATLAB is a loosely or weakly-typed language. Difference between MATLAB and a strongly-typed language is that you don't have to explicitly declare the types of the variables you use. For example, the declarations x=5; x='foo' immediately following one another are perfectly acceptable; the first declaration causes x to be treated as a number, the second changes its treatment to a string
\subsubsection{Python}
Python or Ruby are often referred to as dynamically typed languages, which throw exceptions to signal type errors occurring during execution
\\
% Please add the following required packages to your document preamble:
% \usepackage[normalem]{ulem}
% \useunder{\uline}{\ul}{}
\begin{table}[]
	\centering
	\caption{Type Safety}
	\label{my-label}
	\begin{tabular}{|l|c|}
		\hline
		Languages & Type Safety                                                                                                                           \\ \hline
		Scala     & \begin{tabular}[c]{@{}c@{}}Strongly type, \\ Static type, \\ powerful type Inference\end{tabular}                                     \\ \hline
		Swift     & \begin{tabular}[c]{@{}c@{}}Type check at compile time, \\ Support type inference\end{tabular}                                         \\ \hline
		F\#       & \begin{tabular}[c]{@{}c@{}}Static Type Checking,\\ Compile Time\end{tabular}                                                          \\ \hline
		Rust      & \begin{tabular}[c]{@{}c@{}}Type Safe, \\ escape valve, \\ unsafe to use raw pointers\end{tabular}                                     \\ \hline
		VB.net    & Type safety use for memory security                                                                                                   \\ \hline
		C\#       & \begin{tabular}[c]{@{}c@{}}Static type checking,\\  type checking compile time\end{tabular}                                           \\ \hline
		D         & \begin{tabular}[c]{@{}c@{}}Type safe, \\ compile time\end{tabular}                                                                    \\ \hline
		Oz        & \begin{tabular}[c]{@{}c@{}}Single Assignment variables, \\ Once value is assigned to\\   variable it can never be change\end{tabular} \\ \hline
		Matlab    & \begin{tabular}[c]{@{}c@{}}Weakly type language, \\ no need to assign type explicitly,\end{tabular}                                   \\ \hline
		Python    & Dynamically type language,                                                                                                            \\ \hline
	\end{tabular}
\end{table}

\subsection{Exception Handling}
An exception handler is a block of code that is executed if an exception occurs during the execution of some other block of code. In this sense, exceptions are a kind of control statement. Raising an exception transfers the flow-of-control to exception handling code. User can also throw own created exception.
\begin{table}[]
\centering

\begin{tabular}{|l|l|l|l|}
\hline
\begin{tabular}[c]{@{}l@{}}Lang\\ .\end{tabular}  & Throw                                                             & Handler                                                                                                                                                                                                              & Assertion                                                                                  \\ \hline
\begin{tabular}[c]{@{}l@{}}Sca\\ la\end{tabular}  & throw                                                             & \begin{tabular}[c]{@{}l@{}}try \{ instructions \}\\  catch (exception) \\ \{ instructions\}\\  finally\{instructions\}\end{tabular}                                                                                  & \begin{tabular}[c]{@{}l@{}}Assert(stat\\ ement)\end{tabular}                               \\ \hline
\begin{tabular}[c]{@{}l@{}}Swi\\ ft\end{tabular}  & \begin{tabular}[c]{@{}l@{}}throw exce\\ ption ()\end{tabular}     & \begin{tabular}[c]{@{}l@{}}do\\ \{ try expression ...\\  instructions \}\\  catch exception\\ \{ instructions \}\end{tabular}                                                                                        & \begin{tabular}[c]{@{}l@{}}assert(condi\\ tion,descrip\\ tion)\end{tabular}                \\ \hline
\begin{tabular}[c]{@{}l@{}}Falc\\ on\end{tabular} & \begin{tabular}[c]{@{}l@{}}raise excep\\ tion\end{tabular}        & \begin{tabular}[c]{@{}l@{}}falcon.HTTPError\\ (status,title=None,\\ description=\\ None)\end{tabular}                                                                                                                &                                                                                            \\ \hline
F\#                                               & \begin{tabular}[c]{@{}l@{}}raise exce\\ ption\end{tabular}        & \begin{tabular}[c]{@{}l@{}}try expression\\ with pattern \\ or\\ try expression \\ finally expression\end{tabular}                                                                                                   & \begin{tabular}[c]{@{}l@{}}assert cond\\ ition\end{tabular}                                \\ \hline
Rust                                              & \begin{tabular}[c]{@{}l@{}}Err(excep\\ tion)\end{tabular}         & \begin{tabular}[c]{@{}l@{}}match fun\_nam(x,y)\\  \{\\           Ok(v) =\textgreater \{\\  println!("\{\}", v); \},\\           Err(err) =\textgreater \{\\   println!("\{\}", err);\\  \}\}\end{tabular}            &                                                                                            \\ \hline
\begin{tabular}[c]{@{}l@{}}Vb\\ .Net\end{tabular} & \begin{tabular}[c]{@{}l@{}}throw excep\\ tion\end{tabular}        & \begin{tabular}[c]{@{}l@{}}Try\\ instructions\\ Catch exception \\ When condition\\   instructions\\   ...\\   Finally\\   instructions\\   End Try\end{tabular}                                                     & \begin{tabular}[c]{@{}l@{}}Debug.Ass\\ ert(condi\\ tion)\end{tabular}                      \\ \hline
C\#                                               & \begin{tabular}[c]{@{}l@{}}throw excep\\ tion;\end{tabular}       & \begin{tabular}[c]{@{}l@{}}try \{ instructions \}\\ catch (exception) \\ \{ instructions\}\\ finally \{instructions\}\end{tabular}                                                                                   & \begin{tabular}[c]{@{}l@{}}Debug.Ass\\ ert(condi\\ tion);\end{tabular}                     \\ \hline
D                                                 & throw                                                             & \begin{tabular}[c]{@{}l@{}}try \{ instructions \}\\ catch (exception) \\ \{ instructions\}\\ finally \{instructions\}\end{tabular}                                                                                   &                                                                                            \\ \hline
Oz                                                & \begin{tabular}[c]{@{}l@{}}\{exception.\\ 'raise'X\}\end{tabular} & \begin{tabular}[c]{@{}l@{}}try S catch \\   Pattern\_1 then S1 \\   Pattern\_2 then S2 \\  finally \\    S\_final \\  end\end{tabular}                                                                               &                                                                                            \\ \hline
\begin{tabular}[c]{@{}l@{}}Mat\\ lab\end{tabular} & \begin{tabular}[c]{@{}l@{}}throw(excep\\ tion)\end{tabular}       & \begin{tabular}[c]{@{}l@{}}try\\ tab statements\\ catch exception\\ tab statements\\  end\end{tabular}                                                                                                               & \begin{tabular}[c]{@{}l@{}}assertError\\ (assert\\ able,actual,\\ identifier)\end{tabular} \\ \hline
R                                                 & throw()                                                           & \begin{tabular}[c]{@{}l@{}}tryCatch(\{\\       expr\},\\  war=function(w)\{\\  warning-handler-\\ code\},\\  error = function(e)\\  \{error-handler-\\ code\}, finally = \{\\       cleanup-code\\   \}\end{tabular} & \begin{tabular}[c]{@{}l@{}}assertError\\ (expr,verbo\\ se=FALSE)\end{tabular}              \\ \hline
\begin{tabular}[c]{@{}l@{}}Pyth\\ on\end{tabular} & \begin{tabular}[c]{@{}l@{}}raise excep\\ tion\end{tabular}        & \begin{tabular}[c]{@{}l@{}}try:\\   Tab instructions\\   except exception:\\   Tab instructions\\   else:\\   Tab instructions\\   finally:\\   Tab  instruction\end{tabular}                                        & \begin{tabular}[c]{@{}l@{}}assert cond\\ ition\end{tabular}                                \\ \hline
\end{tabular}
\caption{Exception Handling syntax in different languages  }
\label{my-label}
\end{table}
\subsection{Meta-programming}
Meta-programming is the capability to adapt itself (meta stack overflow which is the place to ask question about stack overflow itself). We can also say the ability to treat programs as their data. It means that a program can be designed to read, generate, analyze or transform other programs, and even modify itself while running. Meta-programming is not one specific technique, but rather an ensemble of concepts and techniques. There are two different ways of doing metaprogramming: on the Syntax level and at Runtime.\\
ection explain these components.
\begin{itemize}
  \item \textbf{Features for Syntax:} These are feature of languages through which Syntax meta-programming apply.
  \item \textbf{Features for Runtime:} These are feature of languages through which Runtime meta-programming apply.
\end{itemize}
\textbf{Reflection:} is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.
\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
\begin{tabular}[c]{@{}l@{}}Prog. \\ Lang.\end{tabular} & \multicolumn{2}{l|}{Ways of Doing}                                                                          & \begin{tabular}[c]{@{}l@{}}Features\\ for compile\\ time\end{tabular} & \begin{tabular}[c]{@{}l@{}}Features\\ for Run\\ Time\end{tabular} \\ \hline
                                                       & \begin{tabular}[c]{@{}l@{}}Compile\\ Time\end{tabular} & \begin{tabular}[c]{@{}l@{}}Run\\ Time\end{tabular} &                                                                       &                                                                   \\ \hline
R                                                      &                                                        & \Checkmark                                                  &                                                                       & Objects                                                           \\ \hline
Scala                                                  & \Checkmark                                                      & \Checkmark                                                  & Reflection                                                            & Macros                                                            \\ \hline
Swift                                                  & \Checkmark                                                      &                                                    &                                                                       & Templates                                                         \\ \hline
Falcon                                                 & \Checkmark                                                      &                                                    &                                                                       & Macro                                                             \\ \hline
F\#                                                    & \Checkmark                                                      & \Checkmark                                                  &                                                                       & Quotation                                                         \\ \hline
Rust                                                   & \Checkmark                                                      &                                                    &                                                                       & Macros                                                            \\ \hline
VB.net                                                 & \Checkmark                                                      & \Checkmark                                                  & Reflection                                                            & Reflection                                                        \\ \hline
C\#                                                    &                                                        & \Checkmark                                                  &                                                                       & Objects                                                           \\ \hline
D                                                      & \Checkmark                                                      &                                                    &                                                                       & Template                                                          \\ \hline
Oz                                                     & x                                                      & x                                                  &                                                                       &                                                                   \\ \hline
Matlab                                                 & x                                                      & x                                                  &                                                                       &                                                                   \\ \hline
Python                                                 &                                                        & \Checkmark                                                  &                                                                       & \begin{tabular}[c]{@{}l@{}}meta-\\ classes\end{tabular}           \\ \hline
\end{tabular}
\caption{Meta programming features in different languages}
\label{my-label}
\end{table}

\subsection{Compiled / interpreted}
Compiled/interpreted: The difference lies not in the language but how the language has been implemented. A compiler translates the source code of the program into another language format that can be directly executed by a lower-level machine. This can be an abstract machine (such as .NET or the Java Virtual Machine) or the actual machine. In the latter case, the language format that is the target of the compiler is machine code. The translation from source code into lower-level code depends on the abstract syntax and on the operational semantics of the programming language. An interpreter executes the source code directly; informally, it may help to think of the interpreter as executing the program line by line. A more correct understanding is that the interpreter walks through the abstract syntax tree generated by the parser and executes each node in this tree. If a node is a leaf, the leaf is executed. If a node is an internal node, each sub-tree is visited and executed. Exactly how this is to be done depends on the abstract syntax and on the underlying semantics of the programming language.
Out of the many programming languages in this world, some of them are called compiled languages while some are interpreted. For compilation, the software uses is called compiler while for interpreter is used for interpreted language. For a compiled language, an interpreter can be built but the reverse is impossible. That is, all the interpreted languages cannot be a compiled language. Additionally, being interpreted or compiled is not the property of the programming languages, but the design of some languages make them unsuitable for native code generation.
\begin{table*}[]
\centering
\caption{compiled vs interpreted}
\label{my-label}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
\hline
        & compiled                                                                                                                                                                                                                                                                                                                                           & interpreted                                                                                                                 & Pre-State Values & Global Assertions & Language Integration                                                                                                                                                                                                                                                   & Security Levels                                                               & enabling / disabling assertions                                                                                                                                                         & debugging support                                                                           & hidden functions & inheritance                                                                                                                   \\ \hline
Scala   & \begin{tabular}[c]{@{}l@{}}actually a compiled , wherein\\   everything you type gets compiled to the byte code and it runs within the\\   JVM.\end{tabular}                                                                                                                                                                                       & illusion of interpreted                                                                                                     & no               & no                & \begin{tabular}[c]{@{}l@{}}import\\   org.scalatest.Assertions.\_\end{tabular}                                                                                                                                                                                         & no                                                                            & \begin{tabular}[c]{@{}l@{}}assume\\   fail\\   cancel\\   succeed\\   intercept\\   exception\\   assertDoesNotCompile\\   assertCompiles\\   assertTypeError\\   withClue\end{tabular} & \begin{tabular}[c]{@{}l@{}}Scala Debugger\\    Intellij IDEA\end{tabular}                   & no               & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that\\   contains asserts\end{tabular} \\ \hline
Swift   & compiled                                                                                                                                                                                                                                                                                                                                           &                                                                                                                             &                  &                   &                                                                                                                                                                                                                                                                        &                                                                               &                                                                                                                                                                                         &                                                                                             &                  &                                                                                                                               \\ \hline
Falcon  & \begin{tabular}[c]{@{}l@{}}compiled, The Falcon compiler contains a meta-compiler{[}23{]} that\\   supports macro expansions. A Falcon Virtual Machine in the standard compiler\\   drives the meta-compiler. Output generated from the meta-compiler is sent to\\   the language lexer as if part of the original source.\end{tabular}            &                                                                                                                             & no               & yes               & import falcon                                                                                                                                                                                                                                                          & no                                                                            & no                                                                                                                                                                                      & falcon command line interpreter                                                             & no               & no                                                                                                                            \\ \hline
F\#     & \begin{tabular}[c]{@{}l@{}}compiled, open source cross platform compiler from F\# Software\\   Foundation\end{tabular}                                                                                                                                                                                                                             &                                                                                                                             & no               & no                & \begin{tabular}[c]{@{}l@{}}open FsUnit\\   {[}\textless{}AbstractClass\textgreater{}{]}{[}\textless{}Sealed\textgreater{}{]}type Assert = class end\end{tabular}                                                                                                       & no                                                                            & no                                                                                                                                                                                      & \begin{tabular}[c]{@{}l@{}}.NET debugger\\   System. Diagnostic. Debug. Assert\end{tabular} & no               & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that contains\\   asserts\end{tabular} \\ \hline
Rust    & \begin{tabular}[c]{@{}l@{}}compiled.\\   First, the Rust compiler does all the Rust specific stuff like\\   type and borrow checking; in the end, it generates LLVM-IR. IR stands for\\   intermediate representation and it's comparable to assembly, but a tiny bit\\   more high level and most importantly: platform independent.\end{tabular} &                                                                                                                             & yes              & yes               &                                                                                                                                                                                                                                                                        & no                                                                            & yes                                                                                                                                                                                     & \begin{tabular}[c]{@{}l@{}}debug\_assert!\\   interpreter\end{tabular}                      & no               & no                                                                                                                            \\ \hline
Vb .Net & version 6 and above, both compiled and interpreted                                                                                                                                                                                                                                                                                                 & interpreted                                                                                                                 & no               & no                & \begin{tabular}[c]{@{}l@{}}Debug.Assert Method\\   System.Diagnostics\\   Namespace\\   Public NotInheritable Class Assert\end{tabular}                                                                                                                                & no                                                                            & no                                                                                                                                                                                      & VBasic .Net Debugger                                                                        & no               & yes                                                                                                                           \\ \hline
C\#     & compiled                                                                                                                                                                                                                                                                                                                                           &                                                                                                                             & no               & no                & \begin{tabular}[c]{@{}l@{}}assert method in class Debug\\   public static class Assert\end{tabular}                                                                                                                                                                    & no                                                                            & \begin{tabular}[c]{@{}l@{}}conditional compilation\\   C\# - .NET’s Base Class Library (BCL) supports similar facility\\   for C\#, C++ and VBA.\end{tabular}                           & C\# debugger                                                                                & no               & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that\\   contains asserts\end{tabular} \\ \hline
D       & compiled                                                                                                                                                                                                                                                                                                                                           &                                                                                                                             & no               & no                & no                                                                                                                                                                                                                                                                     & no                                                                            & no                                                                                                                                                                                      & no                                                                                          & no               & no                                                                                                                            \\ \hline
Oz      & \begin{tabular}[c]{@{}l@{}}yes, Oz code can be\\   compiled into command line executables. The compiled code is not native\\   binary, but a shell script-wrapper with embedded Oz virtual machine bytecode.\end{tabular}                                                                                                                          & yes                                                                                                                         & yes              & yes               & export Literals Assert                                                                                                                                                                                                                                                 & no                                                                            & no                                                                                                                                                                                      & no                                                                                          & no               & no                                                                                                                            \\ \hline
Matlab  &                                                                                                                                                                                                                                                                                                                                                    & \begin{tabular}[c]{@{}l@{}}yes,  you can\\   write code and just execute it from the IDE, without compilation.\end{tabular} & yes              & no                & yes, python, c,c++, C\#, java, fortran                                                                                                                                                                                                                                 & \begin{tabular}[c]{@{}l@{}}fatalAssertThat\\   fataAssertWarning\end{tabular} & \begin{tabular}[c]{@{}l@{}}yes\\   global NDEBUG; NDEBUG=true;\end{tabular}                                                                                                             & \begin{tabular}[c]{@{}l@{}}yes\\   matlab\end{tabular}                                      & no               & no                                                                                                                            \\ \hline
R       & \begin{tabular}[c]{@{}l@{}}an interface to compiled code,\\   because all key routines are run in compiled code (through\\   .C, .Call., .Internal, .Primitive interfaces, etc.) But does not compile\end{tabular}                                                                                                                                 & yes                                                                                                                         & yes              & yes               & \begin{tabular}[c]{@{}l@{}}assertthat\\   -assert\_that() signal an error\\   -see\_if() returns\\   a logical value, with the error message as an attribute.\\   -validate\_that() returns TRUE on\\   success, otherwise returns the error as a string.\end{tabular} & no                                                                            & \begin{tabular}[c]{@{}l@{}}yes\\   customized assert statements can also be written\end{tabular}                                                                                        & no                                                                                          & no               & no                                                                                                                            \\ \hline
Python  &                                                                                                                                                                                                                                                                                                                                                    & yes                                                                                                                         & no               & no                & assert method                                                                                                                                                                                                                                                          & no                                                                            & yes                                                                                                                                                                                     & \begin{tabular}[c]{@{}l@{}}yes\\   python interpreter\end{tabular}                          & no               & yes                                                                                                                           \\ \hline
        & Pre-Post conditions                                                                                                                                                                                                                                                                                                                                & Quantification                                                                                                              & Pre-State Values & Global Assertions & Language Integration                                                                                                                                                                                                                                                   & Security Levels                                                               & enabling / disabling assertions                                                                                                                                                         & debugging support                                                                           & hidden functions & inheritance                                                                                                                   \\ \hline
\end{tabular}
\end{table*}

\subsection{Assertion}
Assertion: specifies that a program satisfies certain conditions at particular points in its execution. An assertion violation indicates a bug in the program. Thus, assertions are an effective means of improving the reliability of programs and function as a systematic debugging tool. There are three types of assertion: pre-conditions, post-conditions and invariants. Preconditions specify conditions at the start of a function; post-conditions specify conditions at the end of a function while invariants specify conditions over a defined region of a program. Asserts are to be used primarily for checking parameter types, classes, or values, checking data structure invariants, checking "can't happen" situations (duplicates in a list, contradictory state variables) or after calling a function, to make sure that its return is reasonable. However, asserts are not to be used for handling run-time errors, like entering a negative number when positive is needed. But used to catching the program errors.
\begin{table*}[]
\centering
\caption{Assertion}
\label{my-label}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|}
\hline
        & Pre-Post conditions & Quantification & Pre-State Values & Global Assertions & Language Integration                                                                                                                                                                                                                                                   & Security Levels                                                               & enabling / disabling assertions                                                                                                                                                         & debugging support                                                                           & inheritance                                                                                                                   \\ \hline
Scala   & no                  &                & no               & no                & import org.scalatest.Assertions.\_                                                                                                                                                                                                                                     & no                                                                            & \begin{tabular}[c]{@{}l@{}}assume\\   fail\\   cancel\\   succeed\\   intercept\\   exception\\   assertDoesNotCompile\\   assertCompiles\\   assertTypeError\\   withClue\end{tabular} & \begin{tabular}[c]{@{}l@{}}Scala Debugger\\    Intellij IDEA\end{tabular}                   & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that\\   contains asserts\end{tabular} \\ \hline
Swift   &                     &                &                  &                   &                                                                                                                                                                                                                                                                        &                                                                               &                                                                                                                                                                                         &                                                                                             &                                                                                                                               \\ \hline
Falcon  & yes                 & yes            & no               & yes               & import falcon                                                                                                                                                                                                                                                          & no                                                                            & no                                                                                                                                                                                      & falcon command line interpreter                                                             & no                                                                                                                            \\ \hline
F\#     & no                  & no             & no               & no                & \begin{tabular}[c]{@{}l@{}}open FsUnit\\   {[}\textless{}AbstractClass\textgreater{}{]}{[}\textless{}Sealed\textgreater{}{]}type Assert = class end\end{tabular}                                                                                                       & no                                                                            & no                                                                                                                                                                                      & \begin{tabular}[c]{@{}l@{}}.NET debugger\\   System. Diagnostic. Debug. Assert\end{tabular} & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that contains\\   asserts\end{tabular} \\ \hline
Rust    & yes                 & yes            & yes              & yes               &                                                                                                                                                                                                                                                                        & no                                                                            & yes                                                                                                                                                                                     & \begin{tabular}[c]{@{}l@{}}debug\_assert!\\   interpreter\end{tabular}                      & no                                                                                                                            \\ \hline
Vb .Net & no                  & no             & no               & no                & \begin{tabular}[c]{@{}l@{}}Debug.Assert Method\\   System.Diagnostics\\   Namespace\\   Public NotInheritable Class Assert\end{tabular}                                                                                                                                & no                                                                            & no                                                                                                                                                                                      & VBasic .Net Debugger                                                                        & yes                                                                                                                           \\ \hline
C\#     & no                  & no             & no               & no                & \begin{tabular}[c]{@{}l@{}}assert method in class Debug\\   public static class Assert\end{tabular}                                                                                                                                                                    & no                                                                            & \begin{tabular}[c]{@{}l@{}}conditional compilation\\   C\# - .NET’s Base Class Library (BCL) supports similar facility\\   for C\#, C++ and VBA.\end{tabular}                           & C\# debugger                                                                                & \begin{tabular}[c]{@{}l@{}}subclass inherits any non-overridden methods in super class that\\   contains asserts\end{tabular} \\ \hline
D       & no                  & no             & no               & no                & no                                                                                                                                                                                                                                                                     & no                                                                            & no                                                                                                                                                                                      & no                                                                                          & no                                                                                                                            \\ \hline
Oz      & yes                 & yes            & yes              & yes               & export Literals Assert                                                                                                                                                                                                                                                 & no                                                                            & no                                                                                                                                                                                      & no                                                                                          & no                                                                                                                            \\ \hline
Matlab  & yes                 & yes            & yes              & no                & yes, python, c,c++, C\#, java, fortran                                                                                                                                                                                                                                 & \begin{tabular}[c]{@{}l@{}}fatalAssertThat\\   fataAssertWarning\end{tabular} & \begin{tabular}[c]{@{}l@{}}yes\\   global NDEBUG; NDEBUG=true;\end{tabular}                                                                                                             & \begin{tabular}[c]{@{}l@{}}yes\\   matlab\end{tabular}                                      & no                                                                                                                            \\ \hline
R       & yes                 & yes            & yes              & yes               & \begin{tabular}[c]{@{}l@{}}assertthat\\   -assert\_that() signal an error\\   -see\_if() returns\\   a logical value, with the error message as an attribute.\\   -validate\_that() returns TRUE on\\   success, otherwise returns the error as a string.\end{tabular} & no                                                                            & \begin{tabular}[c]{@{}l@{}}yes\\   customized assert statements can also be written\end{tabular}                                                                                        & no                                                                                          & no                                                                                                                            \\ \hline
Python  & yes                 & yes            & no               & no                & assert method                                                                                                                                                                                                                                                          & no                                                                            & yes                                                                                                                                                                                     & \begin{tabular}[c]{@{}l@{}}yes\\   python interpreter\end{tabular}                          & yes                                                                                                                           \\ \hline
        & Pre-Post conditions & Quantification & Pre-State Values & Global Assertions & Language Integration                                                                                                                                                                                                                                                   & Security Levels                                                               & enabling / disabling assertions                                                                                                                                                         & debugging support                                                                           & inheritance                                                                                                                   \\ \hline
\end{tabular}
\end{table*}
\subsection{Conditional compilation}
Conditional compilation is a method of producing different results by different parameters provided during compilation of the program. This technique is used when a program is built for different platforms or to run or not to run specific portion of code in a certain condition or to run a program with different version etc. For example, in case of error program should display a debug report so, in C, \#ifdef will be used to define a debug. In HTML, different display sizes can be difined for different plateforms like desktop, tablet, mobile etc. A compiler may be set to define different operating systems like windows, linux, mac etc. to compile the code accordingly. Similarly for javaascript versioning for different browsers etc. 
\subsection{File handling}
File handling is used where data is required to be provided to the program from and to an external source, not using keyboard during program compilation. Data is stored in files that will be used by program during execution. Using file handling technique, data will be read from the file as soon as it requires without waiting for human user to input. Similarly information (output) will be saved to file and program execution will proceed without user to make any interaction like "Press any key to continue...". File handling has three steps 1) Opening a file: Opening a file for reading data from or writing data to an external file. 2) Reading/writing data: Reading data as input for program to store values in variables and operate on it or writing output to the file. 3) Closing a file: Closing the file once it’s use is over. A file can be closed as soon as it’s use is over or it can be closed at the end of program execution before closing the program.
\subsection{Imutable}
In Muti-paradigm programming languages, an immutable object is an object whose state cannot be modified after it is created. This is in contrast to a mutable object (changeable object), which can be modified after it is created. In some cases, an object is considered immutable even if some internally used attributes change but the object's state appears to be unchanging from an external point of view. For example, an object that uses memoization to cache the results of expensive computations could still be considered an immutable object.

\begin{table}[]
\centering
\caption{Table of conditional compilation}
\label{my-label}
\begin{tabular}{|l|l|}
\hline
        & Conditional Compilation                                                                                                                                      \\ \hline
Scala   & \begin{tabular}[c]{@{}l@{}}scala.language.experimental.macros\\ elidable\end{tabular}                                                                        \\ \hline
Swift   & \#if condition                                                                                                                                               \\ \hline
Falcon  &                                                                                                                                                              \\ \hline
F\#     &                                                                                                                                                              \\ \hline
Rust    & \begin{tabular}[c]{@{}l@{}}\#\{{[}\}cfg\{{]}\}\\ for example \#\{{[}\}cfg(foo)\{{]}\}\end{tabular}                                                           \\ \hline
Vb .net & \#ifthen\#else                                                                                                                                             \\ \hline
C\#     & \#if                                                                                                                                                         \\ \hline
D       & \begin{tabular}[c]{@{}l@{}}debug \{    // ... conditionally \\ compiled code ... \} else \{    // ... code \\ that is compiled otherwise ... \}\end{tabular} \\ \hline
Oz      &                                                                                                                                                              \\ \hline
Matlab  & \begin{tabular}[c]{@{}l@{}}\#if (condition) \{do something\} \\ \#else \{do something else\} \#end\end{tabular}                                              \\ \hline
R       &                                                                                                                                                              \\ \hline
Python  &                                                                                                                                                              \\ \hline
\end{tabular}
\end{table}
\subsection{Mutable}
A mutable object, by contrast, has data fields that can be altered. One or more of its methods will change the contents of the object, or it has a Property that, when written into, will change the value of the object.
If you have a mutable object- the most similar one to String is StringBuffer inC\#- then you have to make a copy of it if you want to be absolutely sure it won't change out from under you. This is why mutable objects are dangerous to use as keys into any form of Dictionary or set- the objects themselves could change, and the data structure would have no way of knowing, leading to corrupt data that would, eventually, crash your program.
However, you can change its contents- so it's much, much more memory efficient than making a complete copy because you wanted to change a single character, or something similar.
Generally, the right thing to do is use mutable objects while you're creating something, and immutable objects once you're done. This applies to objects that have immutable forms, of course; most of the collections don't. It's often useful to provide read-only forms of collections, though, which is the equivalent of immutable, when sending the internal state of your collection to other contexts- otherwise, something could take that return value, do something to it, and corrupt your data


\begin{table}[]
\centering
\caption{Mutable programming features in different languages}
\label{my-label}
\begin{tabular}{|l|l|}
\hline
\multicolumn{2}{|c|}{Mutable}                     \\ \hline
Scala  & var maxValue = 100                         \\ \hline
Swift  & var (firstNumber, secondNumber) = (10, 42) \\ \hline
Falcon & array={[}1,2,3{]}                          \\ \hline
F\#    & let a = 1                                  \\ \hline
Rust   & let a = 1                                  \\ \hline
Vb.net & Dim num1  as Integer = 1                   \\ \hline
C\#    & float PI = 3.14149                         \\ \hline
D      & mutable int len = 1                        \\ \hline
Oz     & \{Browse \{4+2\} div 2\}                   \\ \hline
Matlab & h = 6.626068e-34;                          \\ \hline
R      & a\textless{}- 1                            \\ \hline
Python & var a = 1                                  \\ \hline
\end{tabular}
\end{table}

\subsection{imperative control Shahid}
\subsection{Explicit concurrency Shahid}

\section{Discussion and Analysis}
Compiled/interpreted: Major advantage of compilation is the fast performance as it directly used the native code of the target machine and hence has the opportunity to apply quite powerful optimizations during the compile stage. Since the translation is done only once during the compilation, program only needs to be loaded and executed. Major advantage of interpreted is that ease of implementing logic especially for dynamic languages. Also there is no need to compile code and the programs can be executed directly. It is also easier to debug since programs can be executed side by side. Keeping this in mind, compiled languages shall be suitable for the intensive parts of an application requiring heavy resource usage whereas less intensive parts could be written in interpreted languages, e.g. interfaces, invoking the application, ad hoc requests or prototyping.
Asserts are a useful debugging tool. They help detect errors that might otherwise go undetected, detect errors sooner after they occur and also ensure that the statement about the effects of the code is true. The disadvantage of using asserts is reporting an error where none exists and failing to report a bug that does exist. Asserts are also not side-effect free. They also consume extra time and memory to execute. Assert is different from exception handling as occurrence of the exception may go unnoticed while asserts ensure one gets aware of the bug. Asserts are sometimes referred to as lazy exception handling.
Conclusion
If the programmer has to choose between speed and ease of programming, then the choice has to be made between languages opting for compiled or interpreted. A language having the facility of asserts provide the programmers with the ease of detecting errors that would have been impossible to catch using regular exception handling.


\section{Conclusions}

\section{Future Work}

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
\subsection{References}
\begin{thebibliography}{9}
\bibitem @article{clarke2006historical,
  title={A historical perspective on runtime assertion checking in software development},
  author={Clarke, Lori A and Rosenblum, David S},
  journal={ACM SIGSOFT Software Engineering Notes},
  volume={31},
  number={3},
  pages={25--37},
  year={2006},
  publisher={ACM}
}
\bibitem @article{hoare2003assertions,
  title={Assertions: A personal perspective},
  author={Hoare, Charles Antony Richard},
  journal={IEEE Annals of the History of Computing},
  volume={25},
  number={2},
  pages={14--25},
  year={2003},
  publisher={IEEE}
}
\bibitem @article{kamp2012my,
  title={My compiler does not understand me},
  author={Kamp, Poul-Henning},
  journal={Communications of the ACM},
  volume={55},
  number={7},
  pages={51--53},
  year={2012},
  publisher={ACM}
}
\end{thebibliography}
\end{document}